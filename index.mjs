import http from 'http';
import polka from 'polka';
import serveStatic from 'serve-static';
import compression from 'compression';
import htmlMinifier from 'html-minifier';
import htmlEntities from 'html-entities';

const minifyHTML = s => htmlMinifier.minify(s, {
  collapseWhitespace: true,
  includeAutoGeneratedTags: false,
  removeAttributeQuotes: true,
  removeComments: true,
  removeRedundantAttributes: true,
  useShortDoctype: true
});

function generatePreContent(template, req, res) {
  const answerWithPartialContent = Boolean(req.headers['x-partial-content']);

  if (!answerWithPartialContent) {
    return template.split('{{body}}')[0];
  }

  return null;
}

function generatePostContent(template, req, res) {
  const answerWithPartialContent = Boolean(req.headers['x-partial-content']);

  if (!answerWithPartialContent) {
    return template.split('{{body}}')[1];
  }

  return null;
}

/**
 *
 * @param {{ config: WextConfig, page: Page }} options
 */
function wext (options) {
  const { config, page } = options;

  /**
   * @param {http.ClientRequest} req
   * @param {http.ServerResponse} res
   */
  async function wextProxy (req, res) {
    const preContent = generatePreContent(page.template, req, res);

    const { body, head } = await page.handler(req, res);

    if (!preContent && head) {
      res.setHeader(
        'X-Header-Updates',
        config.server.minifyHTML
          ? encodeURIComponent(minifyHTML(head))
          : encodeURIComponent(head)
      );
    }

    res.writeHead(200);

    if (preContent) {
      const preSplit = preContent.split(/\<head\>/);
      const pre = head ? `
        ${preSplit[0]}
        <head>
        ${config.server.minifyHTML ? minifyHTML(head) : head}
        ${preSplit[1]}
      ` : preContent;

      res.write(pre);
    }

    res.write(config.server.minifyHTML ? minifyHTML(body) : body);

    const postContent = generatePostContent(page.template, req, res);

    if (postContent) {
      res.write(postContent);
    }

    res.end();

    return res;
  }

  return wextProxy;
}

/**
 * @typedef ServerConfig
 * @prop {boolean} compression
 * @prop {boolean} serveStatic
 * @prop {boolean} minifyHTML
 */

/**
 * @typedef PageData
 * @prop {string} head
 * @prop {string} body
 */

/**
 * @callback PageHandlerCallback
 * @param {http.ClientRequest} req
 * @param {http.ServerResponse} res
 * @returns {Promise<PageData>}
 */

/**
 * @typedef Page
 * @prop {string} route
 * @prop {string} template
 * @prop {PageHandlerCallback} handler
 */

/**
 * @typedef RouterConfig
 * @prop {Page[]} pages
 */

/**
 * @typedef WextConfig
 * @prop {ServerConfig} server
 * @prop {RouterConfig} router
 */

export default class Wext {
  /**
   * @param {WextConfig} config
   */
  constructor (config) {
    this.config = {
      ...this.defaultConfig,
      ...config
    };

    Object.freeze(this.config);
  }

  get defaultConfig () {
    return {
      server: {
        compression: true,
        serveStatic: true,
        minifyHTML: true
      },
      router: {
        pages: []
      }
    };
  }

  startServer (port = 5000) {
    if (process.env.DEBUG) {
      console.log('startServer')
      console.log('Port:', port);
      console.log('Config:', JSON.stringify(this.config));
    }

    const polkaInstace = polka();

    if (this.config.server.compression) {
      polkaInstace.use(compression());
    }

    if (this.config.server.serveStatic) {
      polkaInstace.use(serveStatic('public'));
    }

    if (this.config.router.pages.length > 0) {
      this.config.router.pages.forEach(page => {
        polkaInstace.get(page.route, wext({
          config: this.config,
          page
        }));
      });
    }

    polkaInstace.listen(port);

    console.log(`Wext server running at http://localhost:5000`);
  }
}